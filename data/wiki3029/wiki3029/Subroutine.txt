Many early computers loaded the program instructions into memory from a punched paper tape.
declare array2 (16,16) float;
Visual Basic 6 uses various terms called ''types'' to define what is being passed as a parameter.
Dim strArray(6) as String
In some languages, each subroutine call also implies automatic testing of the subroutine's return code, or the handling of exceptions that it may raise.
Most modern implementations use a call stack, a special case of the stack data structure, to implement subroutine calls and returns.
One disadvantage of the call stack mechanism is the increased cost of a procedure call and its matching return.
Like a macro &ndash; replace the parameters with the unevaluated argument expressions
JMP MYSUB,I  (Returns to the calling program.)
Indicates that the Function procedure is visible throughout the project, but not visible to a controller of an instance of an object.
There are some seemingly obvious optimizations of procedure calls that cannot be applied if the procedures may have side effects.
Judicious use of subroutines (for example, through the structured programming approach) will often substantially reduce the cost of developing and maintaining a large program, while increasing its quality and reliability.
A similar approach applied in computers which used punched cards for their main input.
In the IBM System/360, for example, the branch instructions BAL or BALR, designed for procedure calling, would save the return address in a processor register specified in the instruction.
Here is an example of recursive subroutine in C/C++ to find Fibonacci numbers:
The function does not return a value and has to be called as a stand-alone function, e.g., Function1
To reduce that overhead, many modern compilers try to delay the use of a call stack until it is really needed.
The extra cost includes incrementing and decrementing the stack pointer (and, in some architectures, checking for stack overflow), and accessing the local variables and parameters by frame-relative addresses, instead of absolute addresses.
In PL/I a called procedure may be passed a ''descriptor'' providing information about the argument, such as string lengths and array bounds.
Indeed, a common use of subroutines is to implement mathematical functions, in which the purpose of the subroutine is purely to compute one or more results whose values are entirely determined by the parameters passed to the subroutine.
char function3(int number)
In systems such as the HP 2100, the JSB instruction would perform a similar task, except that the return address was stored in the memory location that was the target of the branch.
By writing three separate functions with the same name, the programmer has the convenience of not having to remember different names for each type of data.
Reentrant subprograms are also useful in multi-threaded situations, since multiple threads can call the same subprogram without fear of interfering with each other.
That way, the nested execution is free to modify its local variables without concern for the effect on other suspended executions in progress.
Since circular references are not allowed for natural recalculation order, this allows a tree walk without reserving space for a stack in memory, which was very limited on small computers such as the IBM PC.
This allows the procedure to be more general and eliminates the need for the programmer to pass such information.
* '''By reference ByRef''' &ndash; a way of passing the address of an argument to a procedure instead of passing the value.
This allows the procedure to access a copy of the variable.
Other languages, such as C and Lisp, do not distinguish between functions and subroutines.
Variables stored in this scratch space are termed ''local variables'', and the scratch space is termed an ''activation record''.
* '''Public''' (optional) &ndash; indicates that the function procedure is accessible to all other procedures in all modules.
PL/I NONASSIGNABLE parameters, Ada IN parameters
In computer programming, a '''subroutine''' is a sequence of program instructions that perform a specific task, packaged as a unit.
A ''closure'' is a subprogram together with the values of some of its variables captured from the environment in which it was created.
A subprogram with side effects may return different results each time it is called, even if it is called with the same arguments.
As a result, the variable's actual value can't be changed by the procedure to which it is passed.
This is accomplished by storing extra context information within the activation record, also termed a ''display''.
The calling program provides actual values for these parameters, called arguments.
In the compiling method called threaded code, the executable program is basically a sequence of subroutine calls.
For example, any type of function is a subroutine but not main().
* '''Private''' (optional) &ndash; indicates that the function procedure is accessible only to other procedures in the module where it is declared.
This function returns a result (the number 5), and the call can be part of an expression, e.g., x + function2()
Inlining however, will usually increase the code size, unless the program contains only one call to the subroutine, or the subroutine body is less code than the call overhead.
There are a plethora of parameters that could be passed in to the constructor (colour of the trace, starting x and y co-ordinates, trace speed).
So, while those optimizations are safe in purely functional programming languages, compilers of typical imperative programming usually have to assume the worst.
The generic term  '''callable unit''' is sometimes used.
double area(double r) {
In the very early assemblers, subroutine support was limited.
Namely, a location was reserved in each cell to store the ''return'' address.
call change_sign(array2);
strArray = Array("M", "T", "W", "T", "F", "S", "S")
In strictly functional programming languages such as Haskell, subprograms can have no side effects, which means that various internal states of the program will not change.
double rectangle_area = area(3, 4);
Modern languages after ALGOL such as PL/1 and C almost invariably use a stack, usually supported by most modern computer instruction sets to provide a fresh activation record for every execution of a subprogram.
Like call by value except that the parameter is treated as a constant
MYSUB NOP          (Storage for MYSUB's return address.)
This allows the procedure to access the actual variable.
A subroutine may be written so that it expects to obtain one or more data values from the calling program (its parameters or formal parameters).
Not only does this avoid the call overhead, but it also allows the compiler to optimize the procedure's ''body'' more effectively by taking into account the context and arguments at that call.
void function1(void) { /* some code */ }
Such languages typically only support functions, since subroutines that do not return a value have no use unless they can cause a side effect.
double area(double h, double w) {
The name ''subroutine library'' originally meant a library, in the literal sense, which kept indexed collections of tapes or card-decks for collective use.
On those computers, instead of modifying the subroutine's return jump, the calling program would store the return address in a variable so that when the subroutine completed, it would execute an indirect jump that would direct execution to the location given by the predefined variable.
(Examples might include computing the logarithm of a number or the determinant of a matrix.)
return r * r * 3.14;
Functions will always return the same result if repeatedly called with the same arguments.
Recursive languages generally provide a new copy of local variables on each call.
This function converts a number between 0 and 6 into the initial letter of the corresponding day of the week, namely 0 to 'M', 1 to 'T', ..., 6 to 'S'.
The overhead often includes saving and restoring certain processor registers, allocating and reclaiming call frame storage, etc..
The PDP-11 (1970) is one of the first computers with a stack-pushing subroutine call instruction; this feature supports both arbitrarily deep subroutine nesting and also supports recursive subroutines.
The subroutine typically requires standard housekeeping code – both at entry to, and exit from, the function (function prologue and epilogue – usually saving general purpose registers and return address as a minimum).
Argument is evaluated and copy of value is passed to subroutine
These languages use the special keyword void to indicate that a function takes no parameters (especially in C) or does not return any value.
As a result, the variable's actual value can be changed by the procedure to which it is passed.
For example, in the expression (f(x)-1)/(f(x)+1), the function f must be called twice, because the two calls may return different results.
Private Function Function1()
This function does not return a value but modifies the variable whose address is passed as the parameter; it would be called with "function4(&variable_to_increment);".
If the subroutine needed that register for some other purpose (such as calling another subroutine), it would save the register's contents to a private memory location or a register stack.
This approach supported multiple levels of calls; however, since the return address, parameters, and return values of a subroutine were assigned fixed memory locations, it did not allow for recursive calls.
Moreover, memory was a very scarce resource on early computers, and subroutines allowed significant savings in the size of programs.
A language's compiler will usually translate procedure calls and returns into machine instructions according to a well-defined calling convention, so that subroutines can be compiled separately from the programs that call them.
Each procedure call creates a new entry, called a ''stack frame'', at the top of the stack; when the procedure returns, its stack frame is deleted from the stack, and its space may be used for other procedure calls.
The name ''subprogram'' suggests a subroutine behaves in much the same way as a computer program that is used as one step in a larger program or another subprogram.
Here is an example of subroutine overloading in C++:
A subroutine call may also have side effects such as modifying data structures in a computer memory, reading from or writing to a peripheral device, creating a file, halting the program or the machine, or even delaying the program's execution for a specified time.
The instruction sequences corresponding to call and return statements are called the procedure's prologue and epilogue.
A subroutine can be coded so that it may call itself recursively, at one or more places, to perform its task.
Default in most Algol-like languages after Algol 60, such as Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others.
Determining whether a subprogram may have a side effect is very difficult (indeed, undecidable).
Parameter value is copied back on entry to the subroutine and again on return
A recursive subprogram must be reentrant.
Subroutines are a powerful programming tool, and the syntax of many programming languages includes support for writing and using them.
As nested calls accumulate, a call stack structure is formed, consisting of one activation record for each suspended subprogram.
This could be called with various arrays as follows:
To return, the subroutine had only to execute an indirect branch instruction (BR) through that register.
Closures were a notable feature of the Lisp programming language, introduced by John McCarthy.
For example, the call of a procedure ''P'' may store the return address and parameters of the called procedure in certain processor registers, and transfer control to the procedure's body by a simple jump.
Call by constant value
This function does not return a value but modifies the variable whose address is passed as the parameter; it would be called with "Function4(variable_to_increment)".
In logic programming languages, often all subroutines are called predicates, since they primarily determine success or failure.
The discipline of object-oriented programming is based on objects and methods (which are subroutines attached to these objects or object classes).
Reference to argument, typically its address is passed
Moreover, the value of x must be fetched again before the second call, since the first call may have changed it.
Some languages such as Pascal and Ada also support nested subroutines, which are subroutines callable only within the scope of an outer (parent) subroutine.
AA    ...          (Start of MYSUB's body.)
For example, a square root function might be defined to operate on reals, complex values or matrices.
change_sign: procedure(array);
This method allows direct implementation of functions defined by mathematical induction and recursive divide and conquer algorithms.
double circle_area = area(5);
The cost may be realized in increased execution time, or increased processor complexity, or both.
In different programming languages, a subroutine may be called a '''procedure''', a '''function''', a '''routine''', a method, or a '''subprogram'''.
Selectable in most Algol-like languages after Algol 60, such as Algol 68, Pascal, Delphi, Simula, CPL, PL/M, Modula, Oberon, Ada, and many others.
Inner subroutines have access to the local variables of the outer subroutine that called them.
The result of calling it might be assigned to a variable, e.g., num_day = Function3(number).
In the IBM CICS transaction processing system, ''quasi-reentrant'' was a slightly less restrictive, but similar, requirement for application programs that were shared by many threads.
As another example, a subroutine might construct an object that will accept directions, and trace its path to these points on screen.
return selectionnumber;
In strongly typed languages, it is sometimes desirable to have a number of functions with the same name, but operating on different types of data, or with different parameter profiles.
Call by value-result
Unless otherwise specified, arguments are passed by reference.
An environment that fully supports coroutines or lazy evaluation may use data structures other than stacks to store their activation records.
The result of calling it might be assigned to a variable, e.g., num_day = function3(number);.
to call a subroutine called MYSUB from the main program.
Also, when a function or sub is declared, it is given a public, private, or friend designation, which determines whether it can be accessed outside the module or project that it was declared in.
Note that C/C++ functions can have side-effects, including modifying any variables whose addresses are passed as parameters (i.e., ''passed by reference'').
Parameter value is copied back to argument on return from the subroutine
(*pointer_to_var)++;
Function3 = strArray(intValue)
The inserted body can be optimized by the compiler.
declare array1 (-5:10, 3:9)float;
* '''By value ByVal''' &ndash; a way of passing the value of an argument to a procedure instead of passing the address.
Private Function Function3(ByVal intValue as Integer) as String
Indeed, the call stack mechanism can be viewed as the earliest and simplest method for automatic memory management.
An example is a random number function, available in many languages, that returns a different pseudo-random number each time it is called.
Private Function Function2() as Integer
When stack-based procedure calls were first introduced, an important motivation was to save precious memory.
In the HP 2100 assembly language, one would write, for example
Proponents of modular programming (modularizing code) advocate that each subroutine should have minimal dependency on other pieces of code.
Even with this cumbersome approach, subroutines proved very useful.
Some programming languages, such as Pascal, Fortran, Ada and many dialects of BASIC, distinguish between functions or function subprograms, which provide an explicit return value to the calling program, and subroutines or procedures, which do not.
If such coupling is not necessary, their advice is to refactor subroutines to accept passed parameters instead.
If used in a module that contains an Option Private, the procedure is not available outside the project.
Incidentally, a similar method was used by Lotus 1-2-3, in the early 1980s, to discover the recalculation dependencies in a spreadsheet.
The call stack is usually implemented as a contiguous area of memory.
In object-oriented programming, when a series of functions with the same name can accept different parameter profiles or parameters of different types, each of the functions is said to be overloaded.
A method used to eliminate this overhead is ''inline expansion'' or ''inlining'' of the subprogram's body at each call site (versus branching to the subroutine and back).
Further if a subtype can be defined for the reals, to separate positive and negative reals, two functions can be written for the reals, one to return a real when the parameter is positive, and another to return a complex value when the parameter is negative.
There is a significant runtime overhead in a calling a subroutine, including passing the arguments, branching to the subprogram, and branching back to the caller.
For such programs, the call stack mechanism could save significant amounts of memory.
This overhead is most obvious and objectionable in ''leaf procedures'' or ''leaf functions'', which return without making any procedure calls themselves.
Most computers before the late 1960s such as the PDP-8 did not have support for hardware stack registers.
In programming languages such as C, C++, and C#, subroutines may also simply be called functions, not to be confused with mathematical functions or functional programming, which are different concepts.
BB    ...          (Will return here after MYSUB is done.)
A subprogram may find it useful to make use of a certain amount of ''scratch'' space; that is, memory used during the execution of that subprogram to hold intermediate results.
* '''Friend''' (optional) &ndash; used only in a class module.
A subroutine whose purpose is to compute one boolean-valued function (that is, to answer a yes/no question) is sometimes called a predicate.
The call sequence can be implemented by a sequence of ordinary instructions (an approach still used in reduced instruction set computing (RISC) and very long instruction word (VLIW) architectures), but many traditional machines designed since the late 1960s have included special instructions for that purpose.
For example, the use of global variables is generally deemed unwise by advocates for this perspective, because it adds tight coupling between the subroutine and these global variables.
B    ERROR          return code =08   Unexpected condition  }
C, C++, Java (References to objects and arrays are also passed by value)
This unit can then be used in programs wherever that particular task should be performed.
If the programmer wanted the constructor to be able to accept only the color parameter, then he could call another constructor that accepts only color, which in turn calls the constructor with all the parameters passing in a set of ''default values'' for all the other parameters (X and Y would generally be centered on screen or placed at the origin, and the speed would be set to another value of the coder's choosing).
call change_sign(array1);
The subroutine could then return to the main program by executing the indirect jump JMP MYSUB,I which branched to the location stored at location MYSUB.
/* first array bounds from -5 to +10 and 3 to 9 */
Some assemblers would offer predefined macros to generate the call and return sequences.
In object-oriented languages, a significant source of overhead is the intensively used dynamic dispatch for method calls.
The JSB instruction placed the address of the NEXT instruction (namely, BB) into the location specified as its operand (namely, MYSUB), and then branched to the NEXT location after that (namely, AA = MYSUB + 1).
In those languages, function calls are normally embedded in expressions (e.g., a sqrt function may be called as y = z + sqrt(x)).
However, another advantage of the call stack method is that it allows recursive subroutine calls, since each nested call to the same procedure gets a separate instance of its private data.
The function does not return a value and has to be called as a stand-alone function, e.g., function1();
In a multi-threaded environment, there is generally more than one stack.
intValue = intValue + 1
The widespread use of subroutines with side effects is a characteristic of imperative programming languages.
Depending on the implementation, closures can serve as a mechanism for side-effects.
/* second array bounds from 1 to 16 and 1 to 16 */
JSB MYSUB    (Calls subroutine MYSUB.)
In the Visual Basic 6 language, subprograms are termed ''functions'' or ''subs'' (or ''methods'' when associated with a class).
int function2(void)
If procedure ''P'' returns without making any other call, the call stack is not used at all.
Each subroutine could then be provided by a separate piece of tape, loaded or spliced before or after the main program (or "mainline"); and the same subroutine tape could then be used by many different programs.
Recursion is a useful means to simplify some complex algorithms, and breaking down complex problems.
Compilers for Fortran and other languages could easily make use of these instructions when available.
In the C and C++ programming languages, subprograms are termed ''functions'' (or ''member functions'' when associated with a class).
This function converts a number between 0 and 6 into the initial letter of the corresponding day of the week, namely 0 to 'S', 1 to 'M', ..., 6 to 'S'.
Subprograms may be defined within programs, or separately in libraries that can be used by multiple programs.
The subroutine may return a computed value to its caller (its return value), or provide various result values or output parameters.
Procedure calls either behave syntactically as statements (e.g., a print procedure may be called as if x > 0 then print(x) or are explicitly invoked by a statement such as CALL or GOSUB (e.g.
By default PL/I passes arguments by reference.
Private Function Function4(ByRef intValue as Integer)
If ''P'' needs to call another procedure ''Q'', it will then use the call stack to save the contents of any registers (such as the return address) that will be needed after ''Q'' returns.
Subroutines, often collected into libraries, are an important mechanism for sharing and trading software.
Because of the ways in which programs were usually assembled from libraries, it was (and still is) not uncommon to find programs that include thousands of subroutines, of which only a handful are active at any given moment.
Some designs, notably some Forth implementations, used two separate stacks, one mainly for control information (like return addresses and loop counters) and the other for data.
Early languages like Fortran did not initially support recursion because variables were statically allocated, as well as the location for the return address.
declare array(*,*) float;
A subroutine is often coded so that it can be started (called) several times and from several places during one execution of the program, including from other subroutines, and then branch back (''return'') to the next instruction after the ''call'', once the subroutine's task is done.
In this code there are two functions of same name but they have different parameters.
